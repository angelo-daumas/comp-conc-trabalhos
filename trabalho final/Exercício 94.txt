Para compreender a decisão de não permitir uma read-write reentrance na implementação do ReentrantReadWriteLock do Java, é necessário avaliar as premissas básicas de um Read Write Lock. 1) Para adquirir acesso para leitura, não pode haver nenhuma thread escrevendo ou pedindo acesso de escrita. 2) Para adquirir acesso de escrita, não pode haver threads lendo ou escrevendo. Dadas essas premissas, se quiséssemos alterar a implementação original da biblioteca para permitir read-write reentrance, causaríamos uma perda de desempenho que injustificaria termos um Read Write Lock em primeiro lugar. Considere a seguinte situação: uma thread que está com o readLock decide adquirir o writeLock, mas, para isso, deve entrar em espera até que outras possíveis threads que possuam o readLock terminem (ou interrompê-las, o que seria tão ruim quanto ou pior), já que uma thread não pode adquirir o writeLock enquanto houver threads lendo ou escrevendo. O mesmo não poderia ser dito de um write-read reentrance, pois quando uma thread possui o writeLock, não há nenhuma outra thread lendo ou escrevendo, o que permitiria que um readLock fosse adquirido pela mesma sem necessidade de espera ou interrupção da execução natural do programa.
